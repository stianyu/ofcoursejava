# 单调队列

单调队列顾名思义就是队列中元素递增或者递减，元素入队出队都需维护队列的单调性。同单调栈一样，为了保证栈的单调性，在单调减栈中，如果遇到待入栈元素比栈顶大时，需要一直弹出栈顶元素后入栈。单调队列的情形类似，在单调递减队列中，如果遇到待入队元素比队尾大，需要一直让队尾元素出队直到队尾大于待入队元素。

> LeetCode 239. 滑动窗口最大值
>
> 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。（你能在线性时间复杂度内解决此题吗？）
>
> 返回滑动窗口中的最大值。
>
> 示例:
>
> 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
> 输出: [3,3,5,5,6,7] 
> 解释: 
>
>   滑动窗口的位置                最大值
>
> [1  3  -1] -3  5  3  6  7       3
>  1 [3  -1  -3] 5  3  6  7       3
>  1  3 [-1  -3  5] 3  6  7       5
>  1  3  -1 [-3  5  3] 6  7       5
>  1  3  -1  -3 [5  3  6] 7       6
>  1  3  -1  -3  5 [3  6  7]      7

分析：

* 暴力法求解需要O(nk)时间
* 使用单调队列这种数据结构，可以牺牲一点空间复杂度O(k)，把时间复杂度降到O(n)

维护单调减队：

入队：

1. 如果 queue 为空，直接把元素索引放入队尾，进行下一次遍历
2. 如果 queue 不为空，查询队尾存放的下标 j ，如果 nums[j] > nums[i], 则 i 直接入队 ；如果 num[j] <= nums[i]，则弹出 j，继续进入入队操作。

出队：

​      如果 queme 的队首存放的下标 j == i - k，说明当前 queue 的最大值已经不是该窗口下的最大值，次大值才是，队首应该出队。

这道题的入队出队情况：（这个例子没有队首出队的情况）

| i    | nums[i] | nums []表示窗口| 单调减队 queue | 最大值 |
| ---- | ------- | -------------------- | -------------- | ------ |
| 0    | 1       | [1] 3  -1 -3 5 3 6 7 | 1 | -      |
| 1    | 3       | [1 3]  -1 -3 5 3 6 7 | 3 | -      |
| 2    | -1      | [1 3  -1] -3 5 3 6 7 | 3 -1 | 3      |
| 3    | -3      | 1 [3  -1 -3] 5 3 6 7 | 3 -1 -3 | 3      |
| 4    | 5       | 1 3  [-1 -3 5] 3 6 7 | 5 | 5      |
| 5    | 3       | 1 3  -1 [-3 5 3] 6 7 | 5 3 | 5      |
| 6    | 6       | 1 3  -1 -3 [5 3 6] 7 | 6 | 6      |
| 7    | 7       | 1 3  -1 -3 5 [3 6 7] | 7 | 7      |

java 代码:

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] res = new int[nums.length - k + 1];
        Deque<Integer> queue = new ArrayDeque<>();
        for(int i = 0; i < nums.length; i++) {
            // 元素入队
            while(!queue.isEmpty() && nums[queue.peekLast()] <= nums[i]) {
                queue.removeLast();
            }
            queue.addLast(i);
            
            // 队首出队
            // 如果队首放的索引大于 i - k，说明当前的最大值已经不是该窗口下的最大值，次大值才是
            if(i >= k && queue.peekFirst() == i - k) {
                queue.removeFirst();
            }
            
           	// 记录返回值
            if(i >= k - 1) {
                res[i - k + 1] = nums[queue.peekFirst()];
            }
        }
        return res;
    }
}
```

（待更新，2020.06.11）

> LeetCode