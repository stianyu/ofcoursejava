#### 单调栈
- 单调递增栈：栈底到栈顶元素依次递增（找元素右边第一个小的元素）
- 单调递减栈：栈底到栈顶元素依次递减（找元素右边第一个大的元素）

用于解决：可以找到从左/右遍历第一个比它小/大的元素的位置

>例题1：找到每一个数右边第一个比它大的数（单调递增栈）
[10, 5, 8, 12, 6]

`栈顶 [10] 栈底`

`栈顶 [5, 10] 栈底`

`栈顶 [8, ~~5~~, 10] 栈底` ( 8 把 5 删了，所以 8 就是 5 的右边第一个比 5 大的元素)

`栈顶 [12, ~~8, 10~~] 栈底` ( 12 把 8 删了，谁进来把栈顶元素删了，谁就是比出栈元素右边大的第一个元素)

`栈顶 [6, 12] 栈底` (栈里的元素没有出栈，说明他们的右边没有比他们大的元素)

> 例题2：LeetCode84，柱状图中最大的矩形（单调递增栈）
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
求在该柱状图中，能够勾勒出来的矩形的最大面积。
![avatar](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png)
[2, 1, 5, 6, 2, 3]

暴力求解法的思路是，以数组中每个元素值为矩形的高度，要获得最大的矩形，就是要得到整个矩形的宽度最大。

从上面一道题可以看出，单调递增栈的作用是，只要一个已经入栈的元素被一个新的元素逼得出栈，这时新的栈顶元素就是旧栈顶元素右边第一个比它小的元素。和上面例题里“8 把 5 删了，所以 8 就是 5 的右边第一个比 5 大的元素”是反过来的。

利用上述递增栈的特性，可以很容易获得矩形的右边界。
递增栈本来就是一个栈顶比栈底大的栈，因此矩形的左边界就是新栈顶元素。

现在来维护这道题中的【单调递增栈】

1. 元素2入栈，这个时候还不能确定以 2 为高度的矩形的最大面积，因为 2 右边说不定还有比 2 更大的元素，如果有，这个矩形的面积会更大。

    `栈顶 [2] 栈底`

2. 接着元素 1 比栈顶元素 2 小，此时 2 出栈，说明以 2 为高度的最大矩形的边界已经确定了，但以 1 为高度的矩形最大面积还不确定（1 还能继续
往右拓展）， 1 入栈。

    `栈顶 [1] 栈底`

3. 接着考虑元素 5，5 比栈顶元素 1 大，说明以 1 为高度的矩形的最大面积还不能确定（1 还能继续往右拓展）。同样地，以 5 为高度的矩形的最大
面积也不能确定，继续往后考虑数组里的元素。

    `栈顶 [5, 1] 栈底`

4. 接着考虑元素 6，与 5 的情况类似，高度为 1、5、6 的矩形都右向右拓展的可能。

    `栈顶 [6, 5, 1] 栈底`

5. 接着考虑元素 2，2 比栈顶元素 6 小，说明以 6 为高度的矩形的右侧边界已经确定，该矩形已经不能向右拓展了。

    单调递增栈里栈底的元素肯定比栈顶的元素小，所以以 6 为高度的矩形的左侧边界也确定了。

    (左侧边界和 6 入栈时的索引有关，而右侧边界和比 6 小，使 6 出栈的元素的索引有关。因此，以元素的索引作为入栈的元素更加合适。)

    一旦 6 出栈，意味着以 6 为高度的矩形的最大面积已经确定。

    接着，2 比栈顶元素 5 小，这个情况和 6 同理，以 5 为高度的矩形的右侧边界就是使 5 出栈的 2 对应的索引，而矩形的左侧边界就是元素 5 的索引紧挨着的左边索引。
    
    接着，2 比栈顶元素 1 大，说明以 1、2 为高度的矩形的右边界无法确定。2 入栈。

    `栈顶 [2, 1] 栈底`
    
6. 接着考虑元素 3，3 比栈顶元素 2 大，3入栈。

    `栈顶 [3, 2, 1] 栈底`

7. 此时数组中的元素已经遍历完了，但是栈不为空。但矩形右边界已经确定，栈里的元素只要依次出栈的同时，左边界也就确定了。

上述数组在入栈出栈过程中有两个特殊的情况：
* 出栈的时候，栈为空。
* 遍历完之后，栈中还有元素。

面对这种情况，可以数组的两端加入两个值为 0 的元素，这两个 0 元素被称为【哨兵】
1. 当左侧哨兵 0 入栈后，在遍历数组的过程中，每个数组元素都一定比左哨兵大，左哨兵不会弹出来；
2. 当数组遍历完后，考虑右哨兵 0 一定比栈中的元素小，因此右哨兵会依次使栈里的数组元素出栈。这样就cover掉了特殊的情况。

时间复杂度分析：

在遍历数组的整个过程中，每个元素都只出栈入栈一次，因此时间复杂度为 O(n);

空间复杂度分析：

栈占用的空间为 n + 2，因此空间复杂度也为 O(n);

```java
public class Solution {
    public int largestRectangleArea(int[] heights) {
        int res = 0;
        Deque<Integer> stack = new ArrayDeque<>();
        int[] newHeights = new int[heights.length + 2];
        for (int i = 1; i < heights.length + 1; i++) {
            newHeights[i] = heights[i - 1];
        }
        for (int i = 0; i < newHeights.length; i++) {
        	// while循环里维护单调栈的递增特性
            while (!stack.isEmpty() && newHeights[stack.peek()] > newHeights[i]) {
            	// 当数组中要考察的元素比栈顶元素小时，栈顶出栈
            	// 一旦栈顶出栈，则以栈顶元素为矩形高的最大面积确定
                int cur = stack.pop(); 
                int right = i - 1;  // 以 cur 为最大高度的矩形的右边界
                int left = stack.peek();  // 以 cur 为最大高度的矩形的左边界
                res = Math.max(res, (right - left) * newHeights[cur]);
                System.out.println(res);
            }
            stack.push(i);
        }
        return res;
    }

    public static void main(String[] args) {
        int[] heights = new int[]{2, 1, 5, 6, 2, 3};
        Solution solution = new Solution();
        System.out.println(solution.largestRectangleArea(heights));
    }
}
```