###单调栈
- 单调递增栈
- 单调递减栈

用于解决：可以找到从左/右遍历第一个比它小/大的元素的位置

>例题1：找到每一个数右边第一个比它大的数（单调递增栈）

[10, 5, 8, 12, 6]

栈顶 [10] 栈底

栈顶 [5, 10] 栈底

栈顶 [8, ~~5~~, 10] 栈底 ( 8 把 5 删了，所以 8 就是 5 的右边第一个比 5 大的元素)

栈顶 [12, ~~8, 10~~] 栈底 ( 12 把 8 删了，1 进来把栈顶元素删了，谁就是比出栈元素右边大的第一个元素)

栈顶 [6, 12] 栈底 (栈里的元素没有出栈，说明他们的右边没有比他们大的元素)

> 例题2：LeetCode84，柱状图中最大的矩形

[2, 1, 5, 6, 2, 3]

我们来维护一个【单调递增栈】

1. 一开始看 元素2，这个时候还不能确定以 2 为高度的矩形的最大面积，因为 2 右边说不定还有比 2 更大的元素，如果有，这个矩形的面积会更大。

栈顶 [2] 栈底

2. 接着元素 1 比栈顶元素 2 小，此时 2 出栈，说明以 2 为高度的最大矩形的边界已经确定了，但以 1 为高度的矩形最大面积还不确定（1 还能继续
往右拓展）， 1 入栈。

栈顶 [1] 栈底

3. 接着考虑元素 5，5 比栈顶元素 1 大，说明以 1 为高度的矩形的最大面积还不能确定（1 还能继续往右拓展）。同样地，以 5 为高度的矩形的最大
面积也不能确定，继续往后考虑数组里的元素。

栈顶 [5, 1] 栈底

4. 接着考虑元素 6，与 5 的情况类似，高度为 1、5、6 的矩形都右向右拓展的可能。

栈顶 [6, 5, 1] 栈底

5. 接着考虑元素 2，2 比栈顶元素 6 小，说明以 6 为高度的矩形的右侧边界已经确定，该矩形已经不能向右拓展了。又单调递增栈里栈底的元素肯定比
栈顶的元素小，所以以 6 为高度的矩形的左侧边界也确定了。这样一来，左侧边界和 6 入栈时的索引有关，而右侧边界和比 6 小，使 6 出栈的元素的索
引有关。因此，以元素的索引作为入栈的元素更加合适。
一旦 6 出栈，意味着以 6 为高度的矩形的最大面积已经确定。
接着，2 比栈顶元素 5 小，这个情况和 6 同理，以 5 为高度的矩形的右侧边界就是使 5 出栈的 2 对应的索引，而矩形的左侧边界就是元素 5 的索引
紧挨着的左边索引。
接着，2 比栈顶元素 1 小，说明以 1、2 为高度的矩形的右边界还没确定。
2 入栈。

栈顶 [2, 1] 栈底

6. 接着考虑元素 3，3 比栈顶元素 2 大，3入栈。

栈顶 [3, 2, 1] 栈底

7. 此时数组中的元素已经遍历完了，但是栈不为空。但矩形右边界已经确定，栈里的元素只要依次出栈的同时，左边界也就确定了。
上述数组在入栈出栈是有两个特殊的情况：
* 出栈的时候，栈为空。
* 遍历完之后，栈中还有元素。

面对这种情况，可以数组的两端加入两个值为 0 的元素，这两个 0 元素被称为【哨兵】
1. 当左侧哨兵 0 入栈后，在遍历数组的过程中，每个数组元素都一定比左哨兵大，左哨兵不会弹出来；
2. 当数组遍历完后，考虑右哨兵 0 一定比栈中的元素小，因此右哨兵会依次使栈里的数组元素出栈。这样就cover掉了特殊的情况。

时间复杂度分析：
在遍历数组的整个过程中，每个元素都只出栈入栈一次，因此时间复杂度为 O(n);
空间复杂度分析：
栈占用的空间为 n + 2，因此空间复杂度也为 O(n);